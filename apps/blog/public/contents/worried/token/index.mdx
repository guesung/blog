---
title: 토큰은 어디에 저장해야할까?
date: 2023-07-19
lastModified: 2024-07-03
series: worried
tags: 
  - cookie
  - server-action
  - middleware
isPublished: true
description: 
---

{/* https://www.notion.so/guesung/Token-36cf43e1c0264548928c0a4ccdfc530f?pvs=4 */}

# Intro

<Callout title="JWT(JSON Web Token)">
## JWT(JSON Web Token)

: JSON 객체를 사용하여 정보를 안전하게 전송하기 위한 토큰

- 주로 사용자 인증 및 권한 부여 목적으로 사용된다.

### JWT의 구조

1. Header : 헤더
   - **해시 알고리즘**과 **토큰의 타입**을 정의한다.
2. Payload : 내용
   - 전달하는 **데이터(클레임)**를 포함한다.
   - 클레임 : 주체 식별자(`sub`), 사용자 이름(`name`), 토큰 발급시간(`iat`)로 구성되어 있따.
3. Signature : 서명
   - 유저가 지정하는 비밀 코드이다.
   - 토큰의 무결성과 신뢰성을 보장한다.

위와 같이 헤더, 내용, 서명이 `.`을 구분자로 하여 JWT 토큰 1개를 이룬다.

### JWT 예시

- 테스트 : [https://jwt.io/](https://jwt.io/) 에서 해볼 수 있다.

- Encoded
    - 토큰 : `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`
- Decoded
    - Header : `{"alg": "HS256", "typ": "JWT"}`
    - Payload : `{"sub": "1234567890", "name": "John Doe", "iat": 1516239022}`
    - Signature : `SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`


### JWT의 장점

1. 자체 포함 : JWT는 필요한 모든 정보를 자체적으로 포함하므로, 추가적인 서버 호출 없이 인증을 처리할 수 있다.
2. 확장성 : 중앙 집중식 서버 상태 저장소 없이 확장 가능한 인증 매커니즘을 제공한다.
3. 보안 : 서명을 통해 토큰의 <Description content="데이터가 변경되지 않았음을 보장하는 것">무결성</Description>을 검증할 수 있다.

### JWT의 단점
1. 토큰 크기: JWT는 암호화된 정보가 아니라 인코딩된 정보를 포함하므로, 토큰 크기가 클 수 있다.
2. 유출 위험: 비밀 키가 유출되면 모든 토큰이 위조될 위험이 있다.


## Access Token과 Refresh Token

- Access Token : API를 사용하기 위한 인증용 토큰
   - 이 토큰이 만료되면 Access Token이 없는 것과 마찬가지이다.
- Refresh Token : ACcess Token의 유효기간 연장을 위한 토큰
   - Access Token이 만료되면 Refresh Token을 이용하여 새로운 Access Token을 발급받는다.

### 토큰의 요휴 여부 판단
Token을 서버로 보내면, 서버는 JWT 라이브러리의 복호화 로직을 사용하여 서명의 Secret을 확인한다. 복호화된 데이터가 서버 DB에 저장된 토큰의 정보와 일치하는지 비교하여 판단한다.

### JSWT 저장 DB : Redis

JWT는 간단하고 빠른 조회를 위해 no-strictEqual, Non-Relational DB를 사용하는 것이 좋다.

Redis는 비관계형 DB로, Key:Value를 한 세트로 하여 데이터를 관리한다. Redis에 Key: Value형태의 Dictionary로 저장하면 값을 찾는 것도 빠르다.

</Callout>

우리 프로젝트는 JWT를 활용하고 있다.

# 고민
## 토큰을 어디에 저장해야 할까?

웹만 고려했을 경우, 이전 프로젝트에서는 Refresh Token의 경우 쿠키에 저장하여 XSS공격으로부터 보호하였고, Access Token의 경우 local에서 관리하여 CSRF 공격으로부터 보호하였다.

그런데 이번 프로젝트는 모바일 앱에서 웹뷰를 띄우는 형태로 진행이 된다. 이 경우에도 Refresh와 Access 모두 사용하여 토큰을 관리하여야 할까? 다른 프로젝트는 어떻게 했을까?

다른 프로젝트에 대한 코드 및 프로젝트를 분석해보았다.

[React Native 웹뷰 토큰 관리](https://www.notion.so/React-Native-c3a2c54ab7ff4a56b73a1112e737afe9?pvs=21)

### 1. local storage에 저장 - token 한개로 관리

- [디프만의 아맞다](https://github.com/depromeet/ahmatda-web/tree/main)에서는 token을 localStorage에 저장하였다.
- access token과 refresh token을 따로 구분하지 않았다.
- 대신에, 사용자를 구분하는 userToken과 firebase 알림 토큰인 fcmToken을 또 사용하였다.

### 2. asyncStorage에 저장 (Native 하드드라이브)

- [링크](https://wordbe.tistory.com/entry/React-Native-Auth-%EC%9E%90%EB%8F%99%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%9E%90%EB%8F%99%EB%A1%9C%EA%B7%B8%EC%95%84%EC%9B%83)에서는 React Native로 구현하였는데, `asyncStorage`를 사용하여 디바이스의 하드드라이브에 토큰을 저장하였다.
    - 이 방법을 사용한다면, 로그인 > 웹에서 앱으로 토큰 전달 > `asyncStorage`에 저장 > 앱에서 웹으로 필요할 때마다 토큰 저장. 이 방식으로 구현 가능하지 않을까?

### 3. localStorage에 저장 - refresh token과 access token을 구분

- [디프만 - 영감탱](https://github.com/depromeet/ygtang-client)에서는 refresh token과 access token을 모두 관리하였다.
    1. refresh token : local storage에 저장 & react native로 전송 ⇒ 다시 접속했을 때 활용
    2. access token : local storage에 저장 & axios instance에 headers로 설정 ⇒ api 쏠 때 활용

이거다. 이 방법으로 해주면 될 것 같다.

1. 모든 페이지에 공통적으로 적용되는 `_app.tsx` 혹은 `layout.tsx`페이지를 `UserProvider`로 감싼다.
2. UserProvider에서, localStorage의 토큰을 체크한다.
3. access token이 없거나 만료되었다면 서버에 reissue api를 날려 재발급 받는다.
4. refresh token이 없거나 잘못되었다면 로그인 페이지로 `redirect`시킨다.

❗ 위와 같은 방식으로 localStorage를 이용하면 Server에서 먼저 데이터를 받아와서 페이지를 구성해서 넘겨주는 SSR, Hydration 방식을 이용하지 못한다.

위와같은 Next.js의 장점을 활용하지 못한다는 치명적인 단점이 존재한다. 

다른 방법이 없을까?

server에서 먼저 데이터를 fetching한다는 것은, server에 토큰이 존재해야 한다는 말이다. server에 데이터를 저장하고, 접근할 수 있는 방법으로 cookie가 있다. 이전 프로젝트를 리팩토링할 때 이와 같은 방식으로 구현한 적이 있다.

https://github.com/guesung/atties-ver2.0/issues/11

### 4. cookie에 저장 - refresh token과 access token을 구분

- [디프만의 Ding-Dong](https://github.com/depromeet/Ding-dong-fe)에서는 내가 생각한 refresh token와 access token을 구분하였다.

## 결론

1. 서버에서 브라우저에 저장된 값에 접근하기 위해서는 cookie를 사용해야 한다.
2. cookie에 저장된 값은 XSS공격으로부터 안전하다.


# 구현

## 1. 쿠키에 토큰을 저장한다.

  <Callout title="cookie">
    ## cookie
    : 사용자의 컴퓨터에 저장하는 작은 데이터 조각이다.
  
    ### 서버에서 쿠키를 클라이언트에 저장하는 방법
    - 서버가 클라이언트에 응답할 때 쿠키에 저장하고자 하는 정보를 Header의 Set-Cookie로 함께 전달된다.
    `Set-Cookie: key=value; path=/;`
  
    - 클라이언트는 서버로  전송하는 모든 요청에, 현재 브라우저에 저장된 모든 쿠키를 Header의 Cookie로 전달한다.
    `Cookie: key=value; key2=value2;`
  
    ### 클라이언트에서 쿠키를 저장하는 방법
    1. window 객체의 document.cookie에 저장한다.
    `document.cookie = 'key=value; path=/;'`
  
    ### 쿠키의 용도
  
    여러 페이지를 이동할 때마다 로그인을 하지 않아도 사용자 정보를 유지할 수 있게 해주는 것이 쿠키이다.
    1. ID 저장
    2. 로그인 상태 유지
    3. 하루동안 다시 보지 않기
    4. 최근 검색한 상품들을 광고에서 추천
    5. 쇼핑몰 장바구니 기능
  
  </Callout>
  
  <Callout title="cookie vs localStorage">
    ### cookie
    - 4KB의 용량이 작은 매우 작은 양의 데이터를 저장할 때 사용한다.
    - 문자열만 저장 가능하다.
    - HTTP 요청 시 서버가 접근할 수 있다.
    - XSS로부터 안전하다 : 서버에서 쿠키의 httpOnly옵션을 설정하면 JS에서 쿠키에 접근 자체가 불가능하다.
      - XSS : Cross-Site Scripting, 악의적인 스크립트를 삽입하여 사용자의 정보를 탈취하는 공격
    - CSRF로부터 위험하다 : 공격자가 사용자의 HTTP 요청을 가로챈 뒤 악의적인 요청을 보낼 수 있다.
      - CSRF : Cross-Site Request Forgery, 사용자가 의도하지 않은 요청을 보내는 공격
  
    ### localStorage
    - 5MB의 용량이 큰 양의 데이터를 저장할 때 사용한다.
    - 데이터를 영구 저장한다.
    - 문자열만 저장 가능하다.
    - XSS로부터 위험하다.
    - CSRF로부터 안전하다.
  </Callout>
회원가입을 하거나 로그인을 했을 때, 서버로부터 Access Token과 Refresh Token, 그리고 userId를 받는다. 이를 쿠키에 저장한다.

```ts
for (const [cookieKey, cookieValue] of generateCookiesKeyValues({
  accessToken,
  refreshToken,
  userId,
})) {
  document.cookie = `${cookieKey}=${cookieValue}; path=/;`;
}
```


## 2. 쿠키에서 토큰을 꺼내 사용한다.

axios를 이용하여 서버에 HTTP 요청을 할 때, headers에 Access Token을 담아서 보내야 한다. 이를 위해 `axios.interceptors.request.use`를 이용하여 api요청할 때마다 headers 설정을 해주었다.

1. 브라우저에 저장된 cookie값을 꺼낸다.

    ```ts
    const getAuthTokensByCookie = (cookieString: string): Partial<CookieKeyType> => {
    const auth: Partial<CookieKeyType> = {};
    for (const cookie of cookieString.split('; ')) {
      const [key, value] = cookie.split('=');
      if (key === AUTH_COOKIE_KEYS.accessToken) {
        auth.accessToken = value;
      } else if (key === AUTH_COOKIE_KEYS.refreshToken) {
        auth.refreshToken = value;
      } else if (key === AUTH_COOKIE_KEYS.userId) {
        auth.userId = +value;
      }
    }
    return auth;
    };
    const auth = getAuthTokensByCookie(document.cookie);
    ```
    1번에서 저장한 document.cookie를 파싱하는 함수이다. `;`를 기준으로 split한 후, `=`를 기준으로 key와 value를 분리한다. 그리고 분리한 값을 return한다.

2. axios.interceptors.request.use를 이용하여 headers에 access token을 설정한다.
    ```ts
    export const onRequestClient = async (config: InternalAxiosRequestConfig) => {
      try {
        const auth = getAuthTokensByCookie(document.cookie);

        if (auth.accessToken) {
          config.headers['X-AUTH-TOKEN'] = auth.accessToken;
        }
        return config;
      } catch (error) {
        return Promise.reject(error);
      }
    };
    privateApi.interceptors.request.use(onRequestClient, onRequestError);
    ```